
from collections import defaultdict, Counter

class Solution:

  '''
    APPROACH 1: Brute force
    Using double loop check if a person can send friend request to others. This will be O(N^2)
  '''
  def numFriendRequests(self, ages) -> int:
    nums = sorted(ages)[::-1]
    i=0
    cnt = 0
    while i<len(ages):
      j=i+1
      while j<len(nums) and nums[i]>=nums[j] and nums[j]>(0.5*nums[i]+7):

        if nums[i]==nums[j]: cnt+=1
        cnt+=1
        j+=1
      i+=1
    return cnt
  
  '''
    APPROACH 2:
    - To speed up above approach for ex if we are calculating for 16, 18 then we don't care if 16 comes first and 18 in the last and middle
    - we just care the total number of people with 16 age and 18 age as total freiend req will be => freq of 16 * freq 18
    - we need to check if two people are same then exclude that

    OBSERVATIONS
    - roughly there are people of ages 1 - 100 so there are many people of simillar ages

    TC - O(N)
    SC - O(N) were N is the total unique ages
  '''
    
  def numFriendRequests(self, ages) -> int:
    age_groups = Counter(ages)
    total_requests = 0            

    for a, a_cnt in age_groups.items():
      for b, b_cnt in age_groups.items():
        if b>0.5*a+7 and a>=b:
          total_requests += a_cnt * b_cnt

          # if a and b are of same age then remove the self request generated by same age
          # ex - [16, 16] i.e. 2 people with same age
          # so we have a_freq * b_freq = 2 * 2 = 4; so we have to subtract -2 from it for the request they send to themselves; so final = 4 - 2 = 2
          if a == b: total_requests -= a_cnt
    return total_requests
        